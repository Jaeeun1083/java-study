# 자바 데이터 타입, 변수 그리고 배열

`학습할 것`
- 프리미티브 타입 종류와 값의 범위 그리고 기본 값
- 프리미티브 타입과 레퍼런스 타입
- 리터럴
- 변수 선언 및 초기화하는 방법
- 변수의 스코프와 라이프타임
- 타입 변환, 캐스팅 그리고 타입 프로모션
- 1차 및 2차 배열 선언하기
- 타입 추론, var

---------------------------------------------
# 프리미티브 타입 종류와 값의 범위 그리고 기본 값

논리형, 숫자형, 정수형, 실수형이 있으며 값을 할당할 때 **변수의 주소 값에 값이 저장**되는 데이터 타입이다.
해당 데이터 타입은 값이 할당되며 JVM의 **Runtime Data Area 영역의 Stack 에 값이 저장**된다.

| 분류 | 타입 | 기본값 | 값의 범위 | 값의 크기 |
|-----|-----|-----|----------|-----|
| 정수형 | byte | 0 | -128 ~ 127 | 1byte |
|        | short | 0 | -32,768 ~ 32,767 | 2byte |
|        | int | 0 | -2,147.. ~ 2.147.. | 4byte |
|        | long | 0L | - 9,223.. ~ 9.223.. | 8byte |
| 실수형 | float | 0.0f | (3.4 X 10-38) ~ (3.4 X 10.38) | 8byte
|        | double | 0.0 | (1.7 X 10-308) ~ (1.7 X 10308) | 8byte |
| 문자형 | char | '\u0000' | \u0000' 0 ~ 65,535 | 2byte |
| 논리형 | boolean | false | true, false | 1byte |

---------------------------------------------
# 프리미티브 타입과 레퍼런스 타입

### 프리미티브 타입
- 기본형 타입 또는 원시 타입이라고 한다.
- 정수, 실수, 문자, 논리, 리터럴 등의 실제 데이터 값을 저장한다.
- 기본값이 있으므로 null이 존재하지 않는다.
- 값이 할당되면서 JVM의 Runtime Data Area의 Stack 영역에 값이 저장된다.
- 값의 범위를 벗어나면 컴파일 에러가 발생한다.

### 레퍼런스 타입
- 참조 타입이라고 한다.
- class, interface, enum, array, String 타입 등이 있으며 프리미티브 타입을 제외한 모든 타입은 참조형 타입이다.
- null이 존재한다.
- 값이 저장된 곳의 주소값을 저장하는 공간으로 Heap 영역에 저장된다.

---------------------------------
# 리터럴

- 직접 입력된 데이터 자체를 의미한다. 변수에 넣는 변하지 않는 데이터이다.
- 정수, 실수, 문자, 논리, 문자열 리터럴이 존재한다.

```
int number = 20;
```
에서 number가 변수, 20이 literal이다.

---------------------------------
# 변수 선언 및 초기화하는 방법

#### 변수 선언과 초기화란?

데이터를 저장하기 위해 메모리를 할당하는 것을 뜻한다.
이 선언한 변수에 값을 넣는 것을 초기화라고 한다.

```
// 변수 선언 (초기화 하지 않았으므로 쓰레기 값이 들어있다.)
int a; 
float b;
char c;

// 변수 초기화
a = 5;
b = 3.14f;
c= 'C';
```

- 멤버 변수 (클래스 변수, 인스턴스 변수)와 배열의 초기화는 선택적으로 할 수 있으나 지역 변수는 초기화하지 않으면 에러가 발생한다.
```
int a;
int num = a; // 에러 X

public boid method() {
    int b;
    int c = b; // 에러 O
}
```

---------------------------------
# 변수의 스코프와 라이프타임

#### 변수의 스코프란?
변수에 접근하거나 접근할 수 있는 유효 범위를 뜻한다.
#### 변수의 라이프타임
변수가 메모리에 살아있는 기간을 뜻한다.

스코프에 따른 변수의 종류는 **클래스 변수(static 변수), 인스턴스 변수, 지역 변수** 3가지로 나뉜다. 이는 변수의 **선언 위치**에 따라 결정된다.

| 변수의 종류 | 선언 위치 | 초기화 시점 | 변수의 스코프 | 라이프타임 |
|-----|-----|-----|-----|-----|
| 클래스 변수 | 클래스 영역 | 클래스가 처음 로딩될 때 | 클래스 전역 | 클래스가 초기화되고 프로그램이 종료될 때까지
| 인스턴스 변수 | 클래스 영역 | 인스턴스가 생성될 때 | 각각의 인스턴스 | 객체가 생성되고 객체가 메모리에 살아있는 동안
| 지역 변수 | 메서드 영역 | 변수 선언문이 수행될 때 | 메서드 내부 | 변수 선언 이후로부터 블록을 벗어날 때까지

```
class Test {
    int x, y; // 인스턴스 변수
    static int result; // 클래스 변수

    void add(int a, int b) { // a, b : 지역 변수
    x = a;
    y = b;
    int sum = x + y;
    Systme.out.println("Sum = " + sum);

    public static void main(String args[]) {
        Sample obj = new Sample();
        obj.add(10, 20);
    }
}
```

---------------------------------
# 타입 변환, 캐스팅 그리고 타입 프로모션

## - 타입 변환

#### 타입변환이란?
- 선언된 하나의 타입을 다른 타입으로 변환하는 것을 뜻한다.
- 자동 형변환(작은 타입 -> 큰 타입), 명시적 형변환(큰 타입 -> 작은 타입)이 있다.

### 자동 형변환 (= 묵시적 형변환, 확장)
- 메모리 크기가 작은 데이터 타입의 값을 더 큰 범위의 타입에 할당할 경우 동작한다.
```
void 자동_형변환(){ 
    int a = 100; 
    long b = a; 
    float c = b; 
}
```

### 명시적 형변환 (= 축소)
- 메모리 크기가 큰 데이터 타입의 값을 더 작은 범위의 타입에 할당하기 위해서는 명시적 현변환을 해주어야한다.
```
void 명시적_형변환(){ 
    int a = 88; 
    char b = 'c'; 
    b = a; // b의 타입이 더 작기 때문에 컴파일 에러 발생 
    b = (char)a; // 정상적인 형변환 가능 
    
    a = b; // a는 b보다 타입의 범위가 크므로 형변환 필요X
}

```

## - 캐스팅
- 크키가 더 큰 자료형을 더 작은 자료형에 대입할 때 자료형을 명시해서 강제로 넣는 것을 뜻한다. 이 때 데이터 손실이 발생한다.
```
void 캐스팅() { 
    float a = 3.14f; 
    int b = (int)a; 
}

```

## - 프로모션
- 크기가 더 작은 자료형을 더 큰 자료형에 대입할 때 자동으로 형변환되는 현상이다.
```
void 프로모션() { 
    int a = 10; 
    float b = a; 
}
```

---------------------------------
# 1차 및 2차 배열 선언하기

#### 베열이란?
- **선형 자료구조** 중 하나로 동일한 타입의 연관된 데이터를 메모리에 연속적으로 저장하여 하나의 변수에 묶어서 관리하기 위한 자료구조이다.

#### 1차 배열 선언
```
// 크기 할당 X, 초기화 X 선언
int[] arr;
int arr[];

// 크기 할당 O, 초기화 X 선언
int[] arr = new int[5];
String[] arr = new String[5];

// 크기 할당 O, 초기화 O 선언
int[] arr = {1,2,3,4,5};
int[] arr = new int[] {1,2,3,4,5};
```
#### 2차 배열 선언
```
int[][] arr = new int[5][5];
```

---------------------------------
# 타입 추론, var

## 타입추론
- 변수의 타입을 명시적으로 작성하지 않아도 컴파일러가 알아서 변수의 타입을 대입된 리터럴로 추론하는 것을 뜻한다.
```
public static void main(String[] args) {
    var str = "Hello world";

    if (str instanceof String) {
        System.out.println("str의 타입은 String입니다");
    }
}
```
위와 같이 str의 타입을 var로 선언을 하면 컴파일러가 리터럴을 추론하고 str가 String일 것이라고 판단한다.

## var
- var는 자바10부터 도입되어 지역변수를 선언할 때 초깃값을 통해 데이터 타입을 추론하게 한다.
-  var는 **초기값이 있는 지역 변수로만 선언이 가능**하다. 즉 멤버 변수, 필드 선언, 메서드의 파라미터, 리턴 타입으로는 사용할 수 없다.
- var에는 **null이 들어갈 수 없다**.
- **람다 표현식에서는 명시적인 타입을 지정**해야한다.
  - ``` var p = (String s) -> System.out.println("s =" + s); ```